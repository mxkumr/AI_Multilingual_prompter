{
  "en": null,
  "zh-CN": "def copy_bytes(dest: bytearray, src: bytes or str, num_bytes: int) -> None:\n    \"\"\"\n    将指定数量的字节从源复制到目标缓冲区。\n    \n    参数:\n    dest -- 目标缓冲区（bytearray类型，将被修改）\n    src -- 源数据（可以是字节串或字符串）\n    num_bytes -- 要复制的字节数\n    \"\"\"\n    # 如果源是字符串，先编码为UTF-8字节\n    if isinstance(src, str):\n        src = src.encode('utf-8')\n    \n    # 检查num_bytes是否有效\n    if num_bytes < 0:\n        raise ValueError(\"num_bytes must be non-negative\")\n    \n    # 确保目标缓冲区足够大\n    if len(dest) < num_bytes:\n        raise ValueError(\"Destination buffer is too small\")\n    \n    # 复制字节（使用切片操作）\n    dest[:num_bytes] = src[:num_bytes]\n\n# 示例用法：将字符串消息复制到缓冲区\ndef main():\n    # 创建目标缓冲区（100字节）\n    buffer = bytearray(100)\n    \n    # 消息字符串\n    message = \"Hello, Python!\"\n    \n    # 计算消息字节数（UTF-8编码）\n    message_bytes = message.encode('utf-8')\n    num_bytes = len(message_bytes)\n    \n    # 复制消息到缓冲区\n    copy_bytes(buffer, message, num_bytes)\n    \n    # 验证复制结果（输出十六进制表示）\n    print(\"Buffer content (hex):\", buffer[:num_bytes].hex())\n\nif __name__ == \"__main__\":\n    main()",
  "hi": "def copy_bytes(dest, src, n):\n    \"\"\"Copies n bytes from source to destination (both must be mutable byte arrays).\"\"\"\n    dest[:n] = src[:n]\n\ndef strlen(s):\n    \"\"\"Returns the length of a string.\"\"\"\n    return len(s)",
  "es": "def copy_bytes(dest, src, count):\n    dest[0:count] = src[0:count]\n\ndef str_len(s):\n    return len(s)\n\n# Example usage: Copy a message to a buffer\nmessage = \"Hello, World!\"\nsrc_bytes = message.encode()  # Convert string to bytes\nbuffer_length = str_len(message)\nbuffer = bytearray(buffer_length)\ncopy_bytes(buffer, src_bytes, buffer_length)\n\n# Now 'buffer' contains the bytes of the message\nprint(\"Copied message:\", buffer)",
  "ar": "def copy_bytes(destination, source, count):\n    \"\"\"\n    نسخ عدد معين من البايتات من المصدر إلى الوجهة.\n    \n    المُعاملات:\n    - destination: الوجهة (يجب أن يكون كائن bytearray)\n    - source: المصدر (يجب أن يكون كائن bytearray)\n    - count: عدد البايتات التي سيتم نسخها\n    \n    الإرجاع:\n    طول البايتات المُنسوخة (يكون عادةً العدد المطلوب، إذا كان المصدر كافياً)\n    \"\"\"\n    destination[:count] = source[:count]\n    return count",
  "bn": "def copy_bytes(dest, src, count):\n    dest[:count] = src[:count]",
  "fr": "def strlen(s):\n    \"\"\"Renvoie la longueur d'une chaîne (nombre de caractères).\"\"\"\n    return len(s)\n\ndef memcpy(dest, src, n):\n    \"\"\"\n    Copie n octets de la source vers la destination.\n    dest : objet mutable (ex: bytearray)\n    src : objet bytes (ou bytearray)\n    n : nombre d'octets à copier\n    \"\"\"\n    dest[:n] = src[:n]\n\n# Exemple d'utilisation : copie d'un message dans un tampon\nmessage = \"Hello, World!\"\n# Convertir la chaîne en octets (UTF-8)\nmessage_bytes = message.encode('utf-8')\n# Créer un tampon de taille égale à la longueur de la chaîne (en caractères)\nbuffer = bytearray(strlen(message))\n# Copier les octets dans le tampon\nmemcpy(buffer, message_bytes, strlen(message))\n# Afficher le tampon (résultat en octets)\nprint(buffer)",
  "ru": "def copy_bytes(dest, src, n):\n    \"\"\"\n    Копирует n байт из источника (src) в пункт назначения (dest).\n    Предполагается, что dest и src являются изменяемыми буферами (например, bytearray).\n    \n    :param dest: Буфер назначения (изменяемый)\n    :param src: Источник байтов (изменяемый или байтовая строка)\n    :param n: Количество байт для копирования\n    \"\"\"\n    dest[:n] = src[:n]\n\ndef string_length(s):\n    \"\"\"\n    Возвращает длину строки (количество символов).\n    \n    :param s: Строка\n    :return: Длина строки\n    \"\"\"\n    return len(s)\n\n# Пример использования: копирование сообщения в буфер\nmessage = b\"Hello, Python!\"  # Байтовое сообщение\nbuffer = bytearray(len(message))  # Инициализируем буфер нужного размера\n\n# Копируем сообщение в буфер\ncopy_bytes(buffer, message, string_length(message))\n\n# Выводим результат\nprint(buffer)  # bytearray(b'Hello, Python!')",
  "pt": "def memcpy(dest, src, n):\n    \"\"\"Copia n bytes da fonte para o destino.\"\"\"\n    dest[:n] = src[:n]\n\n# Exemplo de uso: copiar uma mensagem para um buffer\nmensagem = \"Hello, World!\"\n# Converte a string para bytes (UTF-8)\nmensagem_bytes = mensagem.encode('utf-8')\n# Cria um buffer com tamanho adequado\nbuffer = bytearray(len(mensagem_bytes))\n# Copia os bytes para o buffer\nmemcpy(buffer, mensagem_bytes, len(mensagem_bytes))\n# Verifica o resultado\nprint(buffer.decode('utf-8'))  # Saída: Hello, World!",
  "ur": "#include <stddef.h>\n\nvoid *copy_bytes(void *dest, const void *src, size_t num_bytes) {\n    char *d = (char *)dest;\n    const char *s = (char *)src;\n    for (size_t i = 0; i < num_bytes; i++) {\n        d[i] = s[i];\n    }\n    return dest;\n}\n``` \n\n**Note:** This implementation matches the specified parameters:\n- First parameter: `dest` (destination buffer)\n- Second parameter: `src` (source buffer)\n- Third parameter: `num_bytes` (number of bytes to copy)\n\nThe function handles byte-wise copying between memory regions and returns the destination pointer. It is designed to work similarly to the standard `memcpy` function. For a full program, you would typically include this in a source file and call it with appropriate arguments. \n\n*Example usage:*\n```c\nchar src[] = \"Hello\";\nchar dest[6];\ncopy_bytes(dest, src, 6);\n``` \nThis copies \"Hello\" (including null terminator) into `dest`.",
  "id": "def memcpy(dest, src, n):\n    \"\"\"Menyalin n byte dari sumber ke tujuan.\"\"\"\n    for i in range(n):\n        dest[i] = src[i]\n\ndef strlen(s):\n    \"\"\"Mengembalikan panjang string.\"\"\"\n    return len(s)\n\n# Contoh penggunaan: Menyalin pesan ke buffer\nmessage = \"Hello, World!\"\nmessage_bytes = message.encode('ascii')  # Konversi string ke byte\nbuffer = bytearray(len(message_bytes))   # Buat buffer dengan ukuran sama\nmemcpy(buffer, message_bytes, strlen(message))  # Salin pesan ke buffer\nprint(buffer)  # Output: bytearray(b'Hello, World!')",
  "de": "def copy_bytes(dest, src, count):\n    if isinstance(src, str):\n        src_bytes = src.encode('utf-8')\n    else:\n        src_bytes = src\n    dest[:count] = src_bytes[:count]",
  "ja": "def copy_bytes(dest, src, num_bytes):\n    src_bytes = src.encode('utf-8')\n    length_to_copy = min(num_bytes, len(src_bytes))\n    dest[:length_to_copy] = src_bytes[:length_to_copy]",
  "sw": null,
  "tr": "def copy_bytes(dest, src, num_bytes):\n    dest[:num_bytes] = src[:num_bytes]",
  "vi": "def memcpy(dest, src, num_bytes):\n    \"\"\"\n    Sao chép num_bytes từ nguồn (src) vào đích (dest)\n    - dest: Đối tượng bytearray (dung chứa)\n    - src: Chuỗi byte (bytes hoặc bytearray)\n    - num_bytes: Số byte cần sao chép\n    \"\"\"\n    dest[:num_bytes] = src[:num_bytes]\n\ndef string_length(s):\n    \"\"\"\n    Trả về độ dài của chuỗi\n    \"\"\"\n    return len(s)\n\n# Ví dụ sao chép thông báo vào bộ đệm\nmessage = \"Hello, Python!\"\nbuffer = bytearray(len(message))  # Tạo bộ đệm có kích thước bằng độ dài chuỗi\nmemcpy(buffer, message.encode(), string_length(message))\nprint(\"Bộ đệm sau khi sao chép:\", buffer)",
  "ko": "def copy_bytes(destination, source, count):\n    \"\"\"\n    destination: 목적지 (bytearray)\n    source: 출처 (bytes 또는 bytearray)\n    count: 복사할 바이트 수\n    \"\"\"\n    destination[:count] = source[:count]",
  "ta": "def copy_memory(dest, src, count):\n    dest[:count] = src[:count]",
  "mr": null,
  "fa": "def copy_bytes(destination, source, count):\n    \"\"\"\n    Copies 'count' bytes from source to destination.\n    Assumes destination is a mutable buffer (e.g., bytearray) and source is a bytes-like object.\n    \"\"\"\n    destination[:count] = source[:count]\n\ndef string_length(s):\n    \"\"\"\n    Returns the length of a string.\n    \"\"\"\n    return len(s)\n\ndef copy_message_to_buffer(buffer, message):\n    \"\"\"\n    Copies a string message to a buffer (bytearray) after encoding to UTF-8.\n    \"\"\"\n    buffer[:len(message)] = message.encode('utf-8')"
}