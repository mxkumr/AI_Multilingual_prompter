{
  "en": "def copy_bytes(dest, src, num_bytes):\n    dest[:num_bytes] = src[:num_bytes]",
  "zh-CN": "def memcpy(dest, src, n):\n    \"\"\"\n    将源内存中的前 n 个字节复制到目标内存。\n    \n    :param dest: 目标缓冲区（必须是 bytearray 类型）\n    :param src: 源数据（bytes 或 bytearray 类型）\n    :param n: 要复制的字节数\n    \"\"\"\n    # 确保复制字节数不超过源数据长度\n    n = min(n, len(src))\n    dest[:n] = src[:n]\n\n# 示例：将消息复制到缓冲区\nif __name__ == \"__main__\":\n    # 创建目标缓冲区（10 字节）\n    buffer = bytearray(10)\n    \n    # 源消息（字符串编码为字节）\n    message = \"Hello, World!\".encode('utf-8')\n    \n    # 复制消息到缓冲区（使用消息长度）\n    memcpy(buffer, message, len(message))\n    \n    # 输出结果（确保复制正确）\n    print(buffer)  # 输出: bytearray(b'Hello, World!')",
  "hi": "def copy_bytes(destination, source, count):\n    \"\"\"\n    Copies 'count' bytes from the source to the destination.\n    - destination: a mutable bytearray (to hold copied bytes)\n    - source: a bytes object (source of bytes to copy)\n    - count: number of bytes to copy\n    \"\"\"\n    destination[:count] = source[:count]\n\ndef string_length(s):\n    \"\"\"\n    Returns the length of a string.\n    \"\"\"\n    return len(s)",
  "es": "def copy_bytes(dest, src, n):\n    dest[:n] = src[:n]\n\ndef string_length(s):\n    return len(s)\n\n# Example usage: Copy a message to a buffer\nbuffer = bytearray(100)  # Create a 100-byte buffer\nmessage = \"Hello, Python!\"  # Example string message\nbytes_message = message.encode('utf-8')  # Convert string to bytes\nlength = string_length(message)  # Get string length\ncopy_bytes(buffer, bytes_message, length)  # Copy bytes to buffer\nprint(buffer)  # Output: bytearray(b'Hello, Python!\\x00\\x00...')",
  "ar": "def copy_bytes(destination, source, num_bytes):\n    # Copy num_bytes from source to destination (assumes destination is mutable like bytearray)\n    destination[:num_bytes] = source[:num_bytes]\n    return num_bytes  # Return the number of bytes copied (length of the copied data)",
  "bn": "def memcpy(dest, src, n):\n    \"\"\"Copy n bytes from src to dest.\"\"\"\n    dest[0:n] = src[0:n]\n\ndef strlen(s):\n    \"\"\"Return the length of a string.\"\"\"\n    return len(s)",
  "fr": "def str_length(s):\n    return len(s)\n\ndef memcopy(dest, src, n):\n    dest[:n] = src[:n]\n\n# Copy message to buffer\nmessage = \"Hello, World!\"\nmessage_bytes = message.encode('utf-8')\nbuffer = bytearray(len(message_bytes))\nmemcopy(buffer, message_bytes, len(message_bytes))",
  "ru": "def memcpy(dest, src, n):\n    \"\"\"\n    Копирует n байтов из источника src в буфер dest.\n    \n    Параметры:\n    dest (bytearray): Буфер назначения (должен быть изменяемым).\n    src (bytes or bytearray): Источник данных.\n    n (int): Количество байтов для копирования.\n    \"\"\"\n    dest[:n] = src[:n]",
  "pt": "def copy_bytes(dest, src, num_bytes):\n    \"\"\"\n    Copia num_bytes do buffer de origem para o buffer de destino.\n    \n    Parâmetros:\n    dest (bytearray): Buffer de destino (deve ser mutável)\n    src (bytes ou bytearray): Buffer de origem\n    num_bytes (int): Número de bytes a copiar\n    \"\"\"\n    dest[:num_bytes] = src[:num_bytes]\n\n# Exemplo de uso: copiar uma mensagem para um buffer\nmessage = \"Hello, World!\"\nbuffer = bytearray(len(message))  # Cria buffer com tamanho igual ao comprimento da string\nmessage_bytes = message.encode('utf-8')  # Converte string para bytes\ncopy_bytes(buffer, message_bytes, len(message_bytes))\n\n# Verifica o resultado\nprint(\"Buffer após cópia:\", buffer)\nprint(\"Mensagem original:\", message)",
  "ur": "#include <stddef.h>\n\nvoid copy_memory(void *dest, const void *src, size_t num_bytes) {\n    char *d = (char *)dest;\n    const char *s = (char *)src;\n    while (num_bytes--) {\n        *d++ = *s++;\n    }\n}\n```\n\n**Explanation:**\n1. **Function Signature:** `void copy_memory(void *dest, const void *src, size_t num_bytes)`\n   - `dest`: Pointer to the destination memory location\n   - `src`: Pointer to the source memory location\n   - `num_bytes`: Number of bytes to copy\n\n2. **How It Works:**\n   - Converts pointers to `char*` for byte-level access\n   - Uses pointer arithmetic to copy each byte sequentially\n   - Efficiently handles any memory size (including overlapping regions, though not optimized for them)\n\n**Example Usage:**\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char source[] = \"Hello, World!\";\n    char buffer[20];\n    \n    // Copy 13 bytes (including null terminator) from source to buffer\n    copy_memory(buffer, source, 13);\n    \n    printf(\"Copied message: %s\\n\", buffer);\n    return 0;\n}\n```\n\n**Note:** The string length function (`strlen`) is separate and would be implemented as:\n```c\nsize_t string_length(const char *str) {\n    const char *p = str;\n    while (*p) p++;\n    return p - str;\n}\n```\n\nThis implementation matches your requirements for memory copying with proper pointer handling and byte-level operations.",
  "id": "def memcopy(dest, src, count):\n    \"\"\"Menyalin sejumlah byte dari sumber ke tujuan.\"\"\"\n    dest[:count] = src[:count]\n\n# Contoh penggunaan: Menyalin pesan ke buffer\nmessage = \"Hello, Python!\"\nbuffer = bytearray(len(message))  # Buat buffer dengan ukuran sesuai panjang pesan\nmemcopy(buffer, message.encode(), len(message))  # Salin pesan ke buffer\nprint(buffer)  # Output: bytearray(b'Hello, Python!')",
  "de": "def copy_bytes(target, source, count):\n    target[:count] = source[:count]",
  "ja": "def copy_bytes(dest, src, n):\n    dest[:n] = src[:n]",
  "sw": null,
  "tr": "def copy_bytes(dest, src, num_bytes):\n    \"\"\"\n    Belirtilen sayıda baytı kaynakten hedefe kopyalar.\n    \n    Args:\n        dest (bytearray): Hedef bellek alanı (bytearray nesnesi).\n        src (bytes): Kaynak bellek alanı (bytes nesnesi).\n        num_bytes (int): Kopyalanacak bayt sayısı.\n    \"\"\"\n    dest[:num_bytes] = src[:num_bytes]\n\n# Örnek Kullanım\nif __name__ == \"__main__\":\n    message = \"Merhaba\"\n    buffer = bytearray(len(message))  # Hedef arabellek (bayt dizisi)\n    message_bytes = message.encode('utf-8')  # Dizeyi baytlara çevir\n    \n    # Mesajı arabelleğe kopyala\n    copy_bytes(buffer, message_bytes, len(message_bytes))\n    \n    print(\"Kopyalanan Mesaj:\", buffer.decode('utf-8'))  # Çıktı: Merhaba",
  "vi": "def copy_bytes(dest, src, num_bytes):\n    \"\"\"Sao chép số byte từ nguồn sang đích.\"\"\"\n    dest[:num_bytes] = src[:num_bytes]\n\ndef string_length(s):\n    \"\"\"Trả về độ dài của chuỗi.\"\"\"\n    return len(s)\n\n# Mã sao chép thông báo vào bộ đệm\nbuffer = bytearray(20)  # Tạo bộ đệm 20 byte\nmessage = \"Hello, world!\"  # Thông báo cần sao chép\nbytes_message = message.encode('utf-8')  # Chuyển chuỗi thành bytes\nnum_bytes = string_length(message)  # Tính độ dài chuỗi (số byte cần sao chép)\n\ncopy_bytes(buffer, bytes_message, num_bytes)\nprint(\"Bộ đệm sau khi sao chép:\", buffer)",
  "ko": "def copy_bytes(dest, src, count):\n    \"\"\"\n    dest: 목적지 (bytearray 타입)\n    src: 출처 (bytes 또는 bytearray 타입)\n    count: 복사할 바이트 수\n    \"\"\"\n    dest[:count] = src[:count]",
  "ta": "def copy_bytes(dest, src, num_bytes):\n    dest[:num_bytes] = src[:num_bytes]\n\ndef string_length(s):\n    return len(s)",
  "mr": "def memcpy(dest, src, count):\n    \"\"\"Copies 'count' bytes from 'src' to 'dest' (both must be bytearray objects).\"\"\"\n    dest[:count] = src[:count]\n\ndef strlen(s):\n    \"\"\"Returns the length of a string.\"\"\"\n    return len(s)\n\n# Example usage:\nmessage = \"Hello, World!\"  # String to copy\nbuffer = bytearray(len(message))  # Buffer with same length as message\n\n# Convert string to bytes and copy to buffer\nmessage_bytes = message.encode('utf-8')\nmemcpy(buffer, message_bytes, len(message_bytes))\n\nprint(\"Copied message:\", buffer.decode('utf-8'))",
  "fa": "def copy_bytes(dest, src, n):\n    \"\"\"Copies n bytes from source to destination.\"\"\"\n    dest[:n] = src[:n]\n\ndef string_length(s):\n    \"\"\"Returns the length of a string.\"\"\"\n    return len(s)\n\n# Example usage: Copy message to buffer\nmessage = \"Hello, Python!\"\nbuffer = bytearray(len(message))\ncopy_bytes(buffer, message.encode(), len(message))"
}