{
  "en": "def memcopy(dest, src, n):\n    dest[:n] = src[:n]",
  "zh-CN": "def copy_bytes(target, source, n):\n    \"\"\"\n    将源缓冲区的前n个字节复制到目标缓冲区。\n    \n    参数:\n    target (bytearray): 目标缓冲区（长度至少为256）\n    source (bytearray): 源缓冲区（长度至少为256）\n    n (int): 要复制的字节数（不超过256）\n    \n    注意: 函数会自动处理边界（n不超过缓冲区长度）\n    \"\"\"\n    # 确保n不超过缓冲区实际长度（安全防护）\n    n = min(n, len(target), len(source))\n    # 使用切片操作高效复制\n    target[:n] = source[:n]",
  "hi": "def copy_bytes(dest, src, count):\n    \"\"\"\n    Copies 'count' bytes from the source buffer to the destination buffer.\n    \n    Args:\n        dest (bytearray): Destination buffer (must be mutable, e.g., bytearray).\n        src (bytes): Source buffer (can be bytes or bytearray).\n        count (int): Number of bytes to copy.\n    \"\"\"\n    dest[:count] = src[:count]",
  "es": "def copy_bytes(dest, src, num_bytes):\n    dest[:num_bytes] = src[:num_bytes]",
  "ar": "def copy_bytes(dest, src, count):\n    \"\"\"\n    نسخ عدد من البايتات من المصدر إلى الوجهة.\n    \n    الوسيطات:\n    dest (bytearray): الوجهة التي سيتم نسخ البايتات إليها.\n    src (bytearray): المصدر الذي سيتم نسخ البايتات منه.\n    count (int): عدد البايتات المراد نسخها.\n    \"\"\"\n    dest[:count] = src[:count]",
  "bn": "def copy_bytes(dest, src, num_bytes):\n    \"\"\"\n    Copies num_bytes from src to dest.\n    \n    Args:\n        dest (bytearray): Destination buffer (must be a bytearray of sufficient size)\n        src (bytes or bytearray): Source buffer\n        num_bytes (int): Number of bytes to copy (<= 256)\n    \"\"\"\n    dest[:num_bytes] = src[:num_bytes]",
  "fr": "def memcopy(dest, src, n):\n    \"\"\"\n    Copie n octets de la source vers la destination.\n    \n    Args:\n        dest (bytearray): Buffer de destination (256 octets minimum).\n        src (bytes or bytearray): Données source à copier.\n        n (int): Nombre d'octets à copier (doit être <= 256).\n    \"\"\"\n    dest[:n] = src[:n]",
  "ru": "def copy_bytes(dest, src, n):\n    \"\"\"\n    Копирует n байтов из источника (src) в назначение (dest).\n    \n    Параметры:\n    dest (bytearray): Буфер назначения (должен быть достаточно большим).\n    src (bytearray): Буфер источника.\n    n (int): Количество байтов для копирования.\n    \"\"\"\n    dest[:n] = src[:n]",
  "pt": "def memcopy(dest, src, n):\n    \"\"\"\n    Copia n bytes da fonte (src) para o destino (dest).\n    \n    Parâmetros:\n    dest (bytearray): Buffer de destino (deve ter tamanho >= n)\n    src (bytes ou bytearray): Buffer de origem\n    n (int): Número de bytes a copiar\n    \"\"\"\n    dest[:n] = src[:n]",
  "ur": "from source to destination\n; Parameters:\n;   First argument: destination address (EDX)\n;   Second argument: source address (ECX)\n;   Third argument: number of bytes to copy (EBX)\n; Buffer size is 256 bytes (safe for copy operations)\n\nmemcpy:\n    push ebp\n    mov ebp, esp\n    ; Load parameters:\n    ; [ebp+8] = destination (EDX)\n    ; [ebp+12] = source (ECX)\n    ; [ebp+16] = count (EBX)\n    mov edi, [ebp+8]    ; Destination address\n    mov esi, [ebp+12]   ; Source address\n    mov ecx, [ebp+16]   ; Byte count\n    rep movsb           ; Copy bytes (ECX times)\n    pop ebp\n    ret\n```\n\n**Note:**  \n- This code assumes standard 32-bit cdecl calling convention where parameters are pushed right-to-left (`count`, `source`, `destination`).  \n- The buffer is guaranteed to be 256 bytes long, so `ecx` (byte count) will not exceed buffer size.  \n- `rep movsb` copies bytes from `[esi]` to `[edi]`, incrementing both pointers each iteration.  \n- Segment registers (`DS`/`ES`) must be properly set to point to valid memory segments (assumed correct for this context).",
  "id": "def memcpy(dest, src, count):\n    \"\"\"\n    Menyalin sejumlah byte dari sumber ke tujuan.\n    \n    Args:\n        dest (bytearray): Buffer tujuan berukuran minimal 256 byte.\n        src (bytes or bytearray): Sumber data yang akan disalin.\n        count (int): Jumlah byte yang akan disalin.\n    \"\"\"\n    # Salin maksimal 'count' byte dari sumber ke tujuan\n    dest[:count] = src[:count]",
  "de": "def copy_bytes(dest, src, n):\n    dest[:n] = src[:n]",
  "ja": "def copy_bytes(dest, src, count):\n    dest[:count] = src[:count]",
  "sw": "def copy_buffer(start, source, count):\n    dest = bytearray(256)  # Initialize 256-byte destination buffer\n    dest[start:start + count] = source[:count]  # Copy 'count' bytes from source\n    return dest",
  "tr": "def copy_bytes(destination, source, count):\n    destination[:count] = source[:count]",
  "vi": "def copy_memory(dest, src, num_bytes):\n    \"\"\"\n    Sao chép num_bytes từ nguồn (src) sang đích (dest).\n    \n    Args:\n        dest (bytearray): Bộ đệm đích (phải là bytearray).\n        src (bytearray): Bộ đệm nguồn (phải là bytearray).\n        num_bytes (int): Số byte cần sao chép.\n    \"\"\"\n    dest[:num_bytes] = src[:num_bytes]",
  "ko": "def copy_bytes(dest, src, num_bytes):\n    dest[:num_bytes] = src[:num_bytes]",
  "ta": "def memcpy(destination, source, count):\n    destination[:count] = source[:count]",
  "mr": "def copy_bytes(dest, src, num_bytes):\n    dest[:num_bytes] = src[:num_bytes]",
  "fa": "def copy_bytes(dest, src, count):\n    dest[:count] = src[:count]"
}